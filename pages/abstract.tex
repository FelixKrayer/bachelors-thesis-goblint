\chapter{\abstractname}

%TODO: Abstract
The precision of interprocedural static analyses depends on the variant of context-sensitivity used. While less context-sensitivity grants faster computation time, it comes with a loss in precision. A portion of this precision is actually lost unnecessarily, as some parts of the caller state are not altered during the call, however it is still overwritten with less precise information from the callee after the call.\\
%TODO: Literature (3.)
We concretize this unnecessary loss for values-of-variables analyses and give an approach to recover it. For this, we define a taint analysis tracking which variables may be written by a procedure call. We use this information to update the caller state only with the information about possibly written variables from the callee state after a call and keep the information of definitely unwritten ones. We implement a version of this approach in the \gob\ analyzer for the C language and perform benchmarks on it. Additionally, we give a similar approach for a specific thread related analysis, where the caller state only needs to be updated with the callee state when a thread was created in the procedure call.\\
The results of our benchmarks show, that actually the precision lost as well as speedup gained through context-insensitivity compared to a fully context-sensitive analysis is rather miniscule for the majority of our benchmark programs. Furthermore, even though our proposed approach recovers a noteworthy portion of the little precision lost, it fails to consistently achieve a shorter computation time than a fully context-sensitive analysis. However, we found that the number of timeout and stack overflow errors can be significantly reduced through context-insensitivity. Thus, our approach is best applied, when errors have to be avoided, but precision is more important than computation time. % Results vary...

%1. (Partial) context-sensitivity in static analysis\\
%2. Precision is lost about caller state when analyzed context insensitively, even about parts of program states that are untouched by the call, especially with variable analyses\\
%3. Not seen in existing literature, others focus on using context sensitivity on selected program elements, but none are concerned with keeping certain parts of a caller state that is untouched\\
%4. Identify unchanged variables/ parts of state in general\\
%5. insensitivity is not that much worse. Taint only usefull, when errors have to be avoided but precision is more useful than speed
