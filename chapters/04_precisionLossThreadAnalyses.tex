% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Combatting the Precision Loss of Thread Analyses}\label{chapter:precisionLossThreadAnalyses}
% local traces
  To (((Something))) M. Schwarz et al. \parencite{schwarz2023clustered}.
  \section{Theory}
  In Chapter 6 of their paper \parencite{schwarz2023clustered} they propose an analysis that identifies threads by their creation history. Among other things, this analysis helps to identify which actions may or may not happen in parallel.\\
  As mentioned, threads are identified by their creation history, which is used as an ID to identify different threads. This history is a sequence of create edges starting with $\textsf{main}$. 
  To prevent such a history to grow to infinity, they define the notion of non-unique thread IDs which may identify multiple threads each.\\
  Formally, the set of possible abstract thread IDs $\mathcal{I}^{\#}$ is $(\textsf{main}\cdot\mathcal{P}^*) \times 2^{\mathcal{P}}$, where $\mathcal{P}$ is the set of create edges and $\mathcal{P}^*$ a sequence of such edges. $\langle u, f \rangle \in \mathcal{P}$ refers to an outgoing edge from program point $u$ which creates a thread starting at $f$.
  In this notion, IDs of the form $(i, \emptyset) \in \mathcal{I}^{\#}$ are unique, while $(i, s) \in \mathcal{I}^{\#}$ are not unique if $s \neq \emptyset$.\\
  To better provide a better understanding of these definitions we explain them with the following example:\\
  %TODO: Example
  \\
  \\
  % TODO: Precision Loss
  \\
  We propose a "thread-create" analysis that checks for each function, whether a thread is possibly created between the entry to it and the return. Note that it does not matter, if a thread is created in the function itself or in another function which the function called. The domain we use for this analysis is the set of boolean values $\mathbb{D}_\textsf{tc} = \{\textsf{true}, \textsf{false}\}$. The analysis tracks whether a function \textit{may} create a thread. Thus, we encode uncertainty, i.e., "a thread \textit{may} have been created" with $\textsf{true}$. Therefore, the state at some program point $\eta_\textsf{tc}\ [v,\bullet]$ answers the question "\textit{May} a thread have been created since the entry of the current function up to the node $v$". 
  
  

  \section{Implementation}
    In this section we describe briefly, how we implemented the thread-create analysis from the previous chapter in \gob\ and how we used it to improve the \texttt{threadId} analysis that already exists in the analyzer.\\
    Similar to the \texttt{taintPartialContexts} analysis from \autoref{sec:implTaint}, we implement a new module \texttt{threadCreate} that implements the interface seen in \autoref{fig:analysis_interface}. In the following we just discuss the implementation of the functions and modules required by the interface. Their meaning to the analyzer is explained in \autoref{sec:implTaint}.

    \paragraph{Domain:}\mbox{}\\
    The Domain \texttt{D} for this analysis only contains the two boolean values, where \texttt{false} stands for "definitely no thread was created" and \texttt{true} for "maybe a thread was created". For this \gob\ provides the \texttt{MayBool} domain implementing this notion with the corresponing ordering.\\
    Similar to the taint analysis, this analysis does not contribute to the overall context of the analyzer, and thus we chose \texttt{Unit} for the module \texttt{C}.

    \paragraph{The \texttt{startstate} function:}\mbox{}\\
    We start analyses with the state that no thread was created and thus \texttt{startstate} returns \texttt{false}.

    \paragraph{Transfer functions:}\mbox{}\\
    Only actions that create a thread have an effect on the state of this analysis. Hence, all regular transfer functions propagate the state from before without any changes.

    \paragraph{Functions for interprocedural analysis:}\mbox{}\\
    For this analysis these functions are implemented as follows:
    \begin{itemize}
      \item \texttt{context}: With the context domain being \texttt{Unit} this function returns the unit element
      \item \texttt{enter}: When entering a function we want to start with a state describing, that no thread was created by this function yet. Thus, the \texttt{enter} function returns \texttt{false}
      \item \texttt{combine}: After returning from a function call, the state should be \texttt{true} if a thread was created by the caller before or by the callee. Therefore, the \texttt{combine} function joins the caller state and the callee return state with a logical \texttt{or}. 
      \item \texttt{return}: This function propagates the state from before.
      \item \texttt{special}: If the special function that is called here is a thread creating function, e.g., \texttt{pthread\_create()}, the state afterwards is \texttt{true}, since a thread has just been created. If the function is unknown, \texttt{true} is returned as well, because a thread might have been created. In all other cases, the previous state is propagated. 
    \end{itemize}

    \paragraph{Functions for the analysis of multithreaded programs:}\mbox{}\\
    We implement the \texttt{threadspawn} function similar to the \texttt{startstate} function. When a thread is entered, the starting state for this thread is \texttt{false}, i.e., no thread has been created yet.\\
    The \texttt{threadCreate} function returns \texttt{true}, because it created a thread and that is what the state is tracking.

    \paragraph{The \texttt{query} function:}\mbox{}\\
    To allow the new thread-create analysis to broadcast its information to other analyses we add a \texttt{MayThreadCreate} query. This query is answered by the thread-create analysis with the current state. Other analysis can send a \texttt{MayThreadCreate} query to gain the information, whether a thread has been created from the beginning of the current function up to the point where the query is sent.

    %TODO: Impl in threadId analysis

