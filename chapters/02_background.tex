% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Background}\label{chapter:background}
%TODO: SOME TEXT!!!

\begin{figure}
  \centering
  \begin{subfigure}{.35\textwidth}
    \centering
    \lstinputlisting[language=C]{../code/02-example_cfg.c}
  \end{subfigure}
  \begin{subfigure}{.35\textwidth}
    \centering
    \begin{tikzpicture}[node distance={50pt}, main/.style = {draw, circle}] 
      \node[main] (0) {$s$};
      \node[main] (1) [below of=0] {$v_1$};
      \node[main] (2) [below right of=1] {$v_2$};
      \node[main] (3) [below left of=2] {$e$};
      \draw[->] (0) -- node[midway, xshift=20pt, yshift=16pt, pos=1] {x = 0;} (1);
      \draw[->] (1) -- node[midway, xshift=19pt, yshift=15pt, pos=1] {\textsf{true}(x == 0)} (2);
      \draw[->] (2) -- node[midway, xshift=35pt, yshift=8pt, pos=1] {x = x + 1;} (3);
      \draw[->] (1) -- node[midway, xshift=-31pt, yshift=25pt, pos=1] {\textsf{false}(x == 0)} (3);
    \end{tikzpicture}
  \end{subfigure}
  \caption{Example program (left) and corresponding CFG (right)}
  \label{fig:example_cfg}
\end{figure}

  \section{Static Analysis}
  Static analysis is defined by Rival~\parencite{rival2020introduction} as "[...]an automatic technique that approximates in a conservative manner semantic properties of programs before their execution". This means that the program is analyzed just by the given source code without execution. The goal is to prove certain properties about the program in a "sound" manner, i.e., any property that is proven to hold actually does hold. However, from failing to prove a property one cannot conclude that the given property does not hold.\\
  In order to prove properties, e.g. finding that a program does not contain races or identifying dead code, we need to gain information about the program. This is done by performing various kinds of analyses. We will focus on flow sensitive analyses from now on, i.e., analyses which find properties of the program dependent on the location within it. We will introduce a syntax to formalize flow sensitive analyses in the following sections. This formalization approach is heavily based on \parencite{apinis2012side}.
    
    // TODO: talk about Abstract Interpretation.
  
    \subsection{Flow sensitive analysis}
    As noted above flow sensitive analyses find properties of the program dependent on the point within the program. Expressed differently this means a flow sensitive analysis will find an overapproximation of states the program may be in for any given point within the program or "program point". This state can describe many things dependent on the analysis performed.\\
    First let us define what a program point is: Consider a \ac{CFG}, where nodes represent points between instructions within the program. Edges are labeled with instructions or checks (from now on collectively called "actions") and describe the transitions between these points (see example \autoref{fig:example_cfg}). Then any node on this \ac{CFG} would be what we call a program point.\\
    Concretely let $N$ be the set of all program points. Furthermore, let $\mathbb{D}$ be a Domain containing abstract states describing concrete states of the program. This means that some $d \in \mathbb{D}$ can describe many states the program can be in.\\ 
    Then an analysis is expected to find a mapping $\eta: N \rightarrow \mathbb{D}$ which maps program points to abstract states describing that location within the program, i.e., for $[n] \in N$, $\eta\ [n]$ should be an abstract state describing all possible states (and possibly more) the program can be in at program point $[n]$.\\
    \\
    % TODO: locals/globals as acronym?
    As an example we will introduce a values-of-variables analysis for integers. This analysis finds a mapping from a set of variables $X$ to abstractions of their possible values at any given program point. Our toy language will support global variables (globals) as well as local variables (locals). The global variables can be accessed and changed by any procedure, while local ones are only visible to the procedure in which it was declared and can only be accessed and changed by this procedure. Therefore, our set $X$ of variables is the disjoint union of globals $G$ and locals $L$: $X = G \uplus L$.
    In the scope of this thesis we will focus on abstracting integer values by sets of integers. Thereby the goal of our values-of-variables analysis is to find a mapping $X \rightarrow 2^\mathbb{N}$ for each program point.\\
    Combining this with the considerations from above, we get that the Domain $\mathbb{D}_\textsf{v}$ for the values-of-variables analysis should be $\mathbb{D}_\textsf{v} = X \rightarrow 2^\mathbb{N}$. Finally, the resulting $\eta_\textsf{v}: N \rightarrow \mathbb{D}_\textsf{v}$ for this analysis describes a mapping $\eta_\textsf{v}\ [n]$ for some program point $[n] \in N$, where $\eta_\textsf{v}\ [n]\ x$ is a set containing all values $x \in X$ may possibly hold at $[n]$. From this we can conclude that $x$ cannot hold any value outside $\eta_\textsf{v}\ [n]\ x$ at program point $[n]$.

    \subsection{Constraint systems}
    We now formulate a way in which we can describe an analysis in the form of constraints. For this we need a partial ordering $\sqsubseteq$ on the domain $\mathbb{D}$.\\
    Then we create a system of constraints which can be solved for a solution. Consider the edges $(u, A, v)$ of the \ac{CFG}, where each edge denotes a transition from program point $[u]$ to program point $[v]$ via the action $A$. Now let each of these edges give rise to a constraint
    \[\eta\ [v] \sqsupseteq [\![A]\!]^{\#}\ (\eta\ [u])\]
    where $[\![A]\!]^{\#}$ denotes the abstract effect of the action $A$ defining our analysis. In addition, we need a start state. This is given by $\textsf{init}^{\#}: \mathbb{D}$ which is defined depending on the analysis. This gives rise to the start constraint $\eta\ [s] \sqsupseteq \textsf{init}^{\#}$ for the starting point of the program $[s] \in N$.\\
    \\
    % TODO: Summarize analysis equations
    We will show these ideas with our example of the values-of-variables analysis: Let us define the partial ordering $\sqsubseteq_\textsf{v}$ that is necessary for building the constraints. We will do this by saying that a mapping $M_1 \in \mathbb{D}_\textsf{v}$ is ordered above another mapping $M_2$ iff for every variable the set it is mapped to in $M_1$ is a superset of the one the variable is mapped to in $M_2$. Formulated formally this is:
    \[M_1, M_2 \in \mathbb{D}_\textsf{v}: M_1 \sqsubseteq_\textsf{v} M_2 \Longleftrightarrow \forall x \in X: M_1\ x \subseteq M_2\ x\]
    Next we define the start state $\textsf{init}^{\#} = M_\top$ for this domain as the mapping that maps every variable to the full set of integers $\mathbb{N}$, i.e., $\forall x \in X: M_\top\ x = \mathbb{N}$. This is because we assume variables to be randomly initialized in our toy language.\\
    It remains to define the abstract effect of actions $[\![A]\!]^{\#}_\textsf{v}$ for our values-of-variables analysis. We will just show the effect of a simple variable assignment:
    \[ [\![ x=y; ]\!]^{\#}_\textsf{v}\ M = M \oplus \{x \mapsto (M\ y) \} \]
    where $M \oplus \{x \mapsto s\}$ denotes that the mapping $M$ is updated such that $x$ will be mapped to the set $s$. A full definition of abstract effects of a values-of-variables analysis can be found at <// TODO >.\\
    % TODO: ref something for full description? Appendix?

    \subsection{Interprocedural analysis}
    So far we only have defined how a program without procedure calls is analyzed. Now we want to introduce procedure calls of the form $f()$. For simplicity, we will only consider argumentless procedure calls without a return value. Arguments and return values can be simulated by using global variables.\\
    Since a call has its own set of local variables to work with and a call stack can contain multiple of the same procedure (e.g. for recursion), we will analyze procedures in their own environment. However, we need to consider global variables and how the procedure affects these.\\
    The idea is to give procedures their own starting states and analyze them similarly as we have done before. The final state of the called procedure is then used to be combined back into the state of the caller before the call. Formalized for an edge $(u, f();, v)$ this looks as follows:
    \[\eta\ [s_f] \sqsupseteq \textsf{enter}^{\#}\ (\eta\ [u]) \]
    \[\eta\ [v] \sqsupseteq  \textsf{combine}^{\#}\ ((\eta\ [u]), (\eta\ [e_f])) \]
    where $[s_f]$ and $[e_f]$ are the start and end node of the \ac{CFG} for procedure $f()$. The functions $\textsf{combine}^{\#}: \mathbb{D} \times \mathbb{D} \rightarrow \mathbb{D}$ and $\textsf{enter}^{\#}: \mathbb{D} \rightarrow \mathbb{D}$ are defined by the analysis. $\textsf{enter}^{\#}$ handles computing the start state for the procedure $f()$, while $\textsf{combine}^{\#}$ describes in what way the caller state and the end state of the callee are merged after the call.\\
    It is worth mentioning at this point that even though a procedure can be called from multiple points within the program we still only analyze the procedure once. For $n$ procedure calls $(u_n, f();, v_n)$ we get $n$ constraints for $[s_f]$: $\eta\ [s_f] \sqsupseteq \textsf{enter}^{\#}\ (\eta\ [u_n])$. We can express this differently in a single constraint as follows:
    \[\eta\ [s_f] \sqsupseteq \bigsqcup \{ d \exists (u_n, f();, v_n) \in Edges:\ \textsf{enter}^{\#}\ (\eta\ [u_n]) = d \}\]
    where $\bigsqcup$ is the least upper bound, i.e., the least $d \in \mathbb{D}$ according to the ordering $\sqsubseteq$ that is ordered above all of its argument elements.\\
    \\
    For our values-of-variables analysis we will show how $\textsf{enter}^{\#}_\textsf{v}$ and $\textsf{combine}^{\#}_\textsf{v}$ are defined. We need to take global variables into account when computing the start state and combining after the call. Therefore, we define the two functions as follows:
    \[\textsf{enter}^{\#}_\textsf{v}\ M = M|_{Globals} \oplus \{x \mapsto \mathbb{N} | \forall x \in X\}|_{Locals_\textsf{ce}} \]
    \[\textsf{combine}^{\#}_\textsf{v}\ (M_\textsf{cr}, M_\textsf{ce}) = M_\textsf{cr}|_{Locals_\textsf{cr}} \oplus M_\textsf{ce}|_{Globals} \]
    where $M|_{Locals}$ and $M|_{Globals}$ refers to the mapping $M$ restricted to only the local or global variables respectively. Note that $Locals_\textsf{ce}$ refers to the locals of the callee while $Locals_\textsf{cr}$ refers to the locals of the caller.\\
    To explain these two function let us first look at $\textsf{enter}^{\#}_\textsf{v}$. This function takes the part of the mapping from the caller that contains information about global variables and adds the information of uninitialized local variables used in the procedure to the state. For $\textsf{combine}^{\#}_\textsf{v}$ the local part from the callee is kept, but it is updated with the global part of the callee return state as this contains the updated information about global variables after the procedure call.\\

    \subsection{Context sensitivity}
    In the previous chapter we approached the analysis of procedures by analyzing them only once with an abstract start state describing all possible concrete states the procedure could start with. We call this behavior "context insensitive" as the procedure is analyzed without differentiating between different contexts it is called in.\\
    This is not very precise as we will exemplify by applying the values-of-variables analysis to the program in \autoref{fig:example_ctx_sens}. We ignore the marked lines of the program for now.\\
    The procedure \texttt{incr();} is called twice: Once with $a = 1$ in \autoref{code:incr1} and once with $a = -3$ in \autoref{code:incr2}. This leads to two constraints for node $[s_{incr}]$: 
      \[\eta_\textsf{v}\ [s_{incr}] \sqsupseteq_\textsf{v} \textsf{enter}^{\#}_\textsf{v}\ \eta_\textsf{v}\ [v_2] = \{a \rightarrow \{1\} \} \]
      \[\eta_\textsf{v}\ [s_{incr}] \sqsupseteq_\textsf{v} \textsf{enter}^{\#}_\textsf{v}\ \eta_\textsf{v}\ [v_5] = \{a \rightarrow \{-3\} \} \]
    leading to $\eta_\textsf{v}\ [s_{incr}] = \{a \rightarrow \{-3, 1\}\}$. At the end point of the call the state will be $\eta_\textsf{v}\ [e_{incr}] = \{a \rightarrow \{-2, 2\}\}$, which is then combined back into the states of nodes in the main procedure for node $[v_6]$ and propagated up to the \texttt{assert(a < 0);} in \autoref{code:assert_a}. The result of this assertion cannot be determined by the analysis even though it is easy for humans to see that it should hold.\\
    \\
    This could have been avoided, if the procedure was analyzed twice, once with each starting state. To achieve this we will need to perform some modifications on our current approach: Instead of searching a mapping $\eta: N \rightarrow \mathbb{D}$ we from now on seek $\eta: (N \times \mathbb{D}) \rightarrow \mathbb{D}$. This allows us to have different states for the same program point. We call the second part of $N \times \mathbb{D}$ "context". For now this context will be the same as the starting state of the current procedure. Therefore, we need to adjust the notion of $\textsf{enter}^{\#}$ and $\textsf{combine}^{\#}$:
    \[\eta\ [s_f, \textsf{enter}^{\#}\ (\eta\ [u, d])] \sqsupseteq \textsf{enter}^{\#}\ (\eta\ [u, d]) \]
    \[\eta\ [v, d] \sqsupseteq \textsf{combine}^{\#}\ ((\eta\ [u, d]), (\eta\ [e_f, \textsf{enter}^{\#}\ (\eta\ [u, d])])) \]
    The main program will always be analyzed just once as in our toy language it is only called initially. The context for its nodes can be chosen arbitrarily, e.g., the one $\textsf{init}^{\#}$ provides: $[s, \textsf{init}^{\#}]$.\\
    \\
    There are no changes we need to perform on the values-of-variables analysis to make it context-sensitive. Solely the changes to the general analysis framework above suffice.\\ Applying this analysis to the example in \autoref{fig:example_ctx_sens} would lead to the procedure \texttt{incr()} being analyzed twice with different contexts, assuming we still ignore the marked lines. This leads to the following two entry constraints for different unknowns of the constraint system:
    \[\eta_\textsf{v}\ [s_{incr}, \{a \rightarrow \{1\} \}] \sqsupseteq_\textsf{v} \{a \rightarrow \{1\} \} \]
    \[\eta_\textsf{v}\ [s_{incr}, \{a \rightarrow \{-3\} \}] \sqsupseteq_\textsf{v} \{a \rightarrow \{-3\} \} \]
    For node $[v_6]$ only the state $\eta_\textsf{v}\ [e_{incr}, \{a \rightarrow \{-3\} \}] = \{a \rightarrow \{-2\}\}$ is combined into the caller state before the call. With this information we can safely say that the assertion in the following \autoref{code:assert_a} will hold.

    \subsection{Partial context sensitivity}
    While the context-sensitive approach from the previous section might be very precise, it can be quite costly in terms of computation time. To reach a middle ground between a context insensitive and a fully context-sensitive analysis, one could propose an approach where only a part of the domain $\mathbb{D}$ is used as a context to differentiate function calls.\\
    Let $\mathbb{D} = \mathbb{D}_\textsf{ctx} \times \mathbb{D}_\textsf{rem}$. The domain is now a product of one part used for contexts $\mathbb{D}_\textsf{ctx}$ and the remaining part $\mathbb{D}_\textsf{rem}$.\\ 
    Again we need to change the definition of the mapping we want to compute: It now is $\eta: (N \times \mathbb{D}_\textsf{ctx}) \rightarrow \mathbb{D}$. Additionally, $\textsf{enter}^{\#}$ and $\textsf{combine}^{\#}$ are changed as follows:
    \[\eta\ [s_f, \langle \textsf{enter}^{\#}\ (\eta\ [u, c]) \rangle_1] \sqsupseteq \textsf{enter}^{\#}\ (\eta\ [u, c]) \]
    \[\eta\ [v, c] \sqsupseteq \textsf{combine}^{\#}\ ((\eta\ [u, d]), (\eta\ [e_f, \langle \textsf{enter}^{\#}\ (\eta\ [u, c]) \rangle_1 ])) \]
    where $\langle d \rangle_1$ extracts the first part of a tuple $d \in (\mathbb{D}_\textsf{ctx} \times \mathbb{D}_\textsf{rem})$. This formalization results in multiple constraint for a single starting variable with context $[s_f, c]$. This can alternatively be formulated as 
    \[\eta\ [s_f, c] \sqsupseteq \bigsqcup \{ (c, d) | \exists (u_n, f();, v_n) \in Edges:\ \textsf{enter}^{\#}\ (\eta\ [u_n, c_n]) = (c, d) \} \]
    With this formal model we have the option to perform an analysis completely context sensitively ($\mathbb{D} = \mathbb{D}_\textsf{ctx} \times (\bullet)$), completely context insensitively ($\mathbb{D} = (\bullet) \times \mathbb{D}_\textsf{rem}$) or anything in between, where $\{(\bullet)\}$ is the "unit domain" which contains exactly one element with the trivial ordering $(\bullet) \sqsubseteq (\bullet)$.
    \\
    We have to note here that there are some severe issues with the approach for (partial) context-sensitive analysis described in this thesis: The resulting system of constraints may not be finite and some variables in the constraint system may depend on an infinite number of other variables. This can result in a very hard or even impossible to solve constraint system. While we will stick with this formal approach for this thesis for the sake of simplicity, an escape route to this issue is described in \parencite{apinis2012side}.

    \subsection{Precision loss}\label{section:precisionLoss}
    The main source of the precision loss of context-insensitive or partially context-sensitive analysis is the join over all states with the same context. 

    Let us now again consider the example program \autoref{fig:example_ctx_sens}. This time we take the marked lines into account. When the program is analyzed context insensitively, not only will the state at the start node represent two possible values for the global variable \texttt{a}, but also for \texttt{c}. The state will therefore be 
    \[\eta_\textsf{v}\ [s_{incr}, (\bullet)] = \{a \rightarrow \{-3, 1\}, c \rightarrow \{-10, 10\}\} \]
    Even though the variable \texttt{c} is never changed within \texttt{incr()}, the mapping $c \rightarrow \{-10, 10\}$ is still copied into the caller state when combining the states for node $[v_5, (\bullet)]$. Therefore, the assertion in \autoref{code:assert_c} cannot be determined to hold solely with the information gained by context insensitive values-of-variables analysis. This precision loss could easily be avoided if we had some idea which global variables are definitely not changed by a procedure call.

    \begin{figure}
      \centering
      \begin{subfigure}{.35\textwidth}
        \centering
        \lstinputlisting[escapechar=|, language=C]{../code/02-example_ctx_sens.c}
      \end{subfigure}
      \begin{subfigure}{.30\textwidth}
        \centering
        \begin{tikzpicture}[node distance={40pt}, main/.style = {draw, circle}] 
          \node[main] (0) {$s$};
          \node[main] (1) [below of=0] {$v_1$};
          \node[main] (2) [below of=1] {$v_2$};
          \node[main] (3) [below of=2] {$v_3$};
          \node[main] (4) [below of=3] {$v_4$};
          \node[main] (5) [below of=4] {$v_5$};
          \node[main] (6) [below of=5] {$v_6$};
          \node[main] (7) [below of=6] {$v_7$};
          \node[main] (8) [below of=7] {$e$};
          \draw[->] (0) -- node[midway, xshift=20pt, yshift=9pt, pos=1] {a = 1;} (1);
          \draw[->] (1) -- node[midway, xshift=20pt, yshift=9pt, pos=1] {\colorbox{TUMAccentLightBlue}{c = 10;}} (2);
          \draw[->] (2) -- node[midway, xshift=20pt, yshift=9pt, pos=1] {incr();} (3);
          \draw[->] (3) -- node[midway, xshift=20pt, yshift=9pt, pos=1] {a = -3;} (4);
          \draw[->] (4) -- node[midway, xshift=22pt, yshift=9pt, pos=1] {\colorbox{TUMAccentLightBlue}{c = -10;}} (5);
          \draw[->] (5) -- node[midway, xshift=20pt, yshift=9pt, pos=1] {incr();} (6);
          \draw[->] (6) -- node[midway, xshift=35pt, yshift=9pt, pos=1] {assert(a < 0);} (7);
          \draw[->] (7) -- node[midway, xshift=35pt, yshift=9pt, pos=1] {\colorbox{TUMAccentLightBlue}{assert(c < 0);}} (8);
        \end{tikzpicture}
      \end{subfigure}
      \begin{subfigure}{.30\textwidth}
        \centering
        \begin{tikzpicture}[node distance={50pt}, main/.style = {draw, circle}] 
          \node[main] (0) {$s_{incr}$};
          \node[main] (1) [below of=0] {$e_{incr}$};
          \draw[->] (0) -- node[midway, xshift=28pt, yshift=11pt, pos=1] {a = a + 1;} (1);
        \end{tikzpicture}
      \end{subfigure}
      \caption{Example program (left) and corresponding CFGs for \texttt{main} (middle) and \texttt{incr} (right)}
      \label{fig:example_ctx_sens}
    \end{figure}

