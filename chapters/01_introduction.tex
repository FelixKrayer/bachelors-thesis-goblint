% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Introduction}\label{chapter:introduction}
  Abstract interpretation is a fascinating theory. When its principles are used in static analysis, one can proof certain properties about computer programs. Through the sound abstractions of abstract interpretation it is ensured that any proven property holds true for all possible executions of a program. The most interesting parts of this application are the different ways by which states of a program can be abstracted and how these abstractions can be combined to gain various kinds of information about a program.\\
  The \gob\ analyzer is a project that applies the principles of abstract interpretation to create a static analyzer \parencite{goblintHome}.\\
  This analyzer is specialized in, but not limited to finding concurrency bugs. These are some properties it aims to check:
  \begin{itemize}
    \item Race Detection: Checking that accesses to shared memory never happens simultaneously.
    \item Assertions and Dead Code: Checking whether specific logical expressions are definitely true at given points within the program. 
    \item Integer Overflows: Verifying that no integer overflows occur in the program.
  \end{itemize}
  To gain information about a program, \gob\ performs various kinds of analyses on the source code. These analyses abstract states of the program in different ways. They are also able to communicate with each other to profit from the information gained by other analyses. Because it is easily expandable, \gob\ is an interesting framework to try out new approaches in static analysis.\\
  \\
  The analyzer is highly configurable. This allows the user to fine-tune the degree of precision they wish. However, it has to be considered that usually a higher degree of precision also results in a higher computation time.\\
  With such a configuration option the user is able to specify the degree of context sensitivity for each analysis. It is possible to set an analysis to be performed full context sensitively, context insensitively or partially context sensitively. Context sensitivity describes the degree to which entry states of functions are differentiated.\\
  \\
  Consider the program in \autoref{fig:exampleIntro}. Assume this program is analyzed with the goal to find which values the program variables can have during program execution. For that an analysis is used that tracks a set of integers for each variable, i.e., it computes an abstract state describing the possible values of all variables for each program point. The abstract state (in this case a set of values per variable) for a program point is computed by applying effect of an action, e.g., an instruction, to the state before this action. Most actions have effects that are easily computable, however function calls are of a more complicated nature, as they can be called from multiple places in a program.\\
  The program in \autoref{fig:exampleIntro} contains two calls to \texttt{function()}, one in \autoref{code:call1} and the other in \autoref{code:call2}. If this program is analyzed context sensitively, the function is analyzed twice: Once with an abstract entry state describing that "\texttt{glob} = 1" and once with a state describing "\texttt{glob} = 2". However, if the analysis is performed context insensitively, both of these two entry states are joined into one abstract state which is used to analyze the function only once. This joined abstract state then has to describe the concrete states, where "\texttt{glob} = 1 or \texttt{glob} = 2", which is less precise than either of the individual states from before.\\
  When the state after a function call is computed, the information about \texttt{glob} is taken from the state returned from the callee. This is because \texttt{glob} is a global variable and thus its value can be changed in function calls.\\
  However, consider the case, where \texttt{glob} was not changed during the call to \texttt{function}. Then the information about \texttt{glob} in the callee return state is the same as in the entry state for that specific call. This means, that in the case of the context-insensitive analysis, the less precise information "\texttt{glob} = 1 or \texttt{glob} = 2" from the joined entry state is used for \texttt{glob} after both calls. This is a loss of precision, considering that the value of \texttt{glob} was not altered in the call, and it would be sound to keep the information about \texttt{glob} from before each call.\\
  \\
  We think this precision loss is avoidable in many cases, where a piece of less precise information is taken from the callee state, even though that piece of information was not changed during the call. Thus, in this thesis we explore a way to reduce this kind of precision loss of partial contexts in abstract interpretation. 

  \begin{figure}
    \centering
    \begin{subfigure}{0.35\textwidth}
      \centering
      \lstinputlisting[escapechar=|, language=C]{../code/01-example_intro.c}
    \end{subfigure}
    \caption{C code sample with multiple function calls}
    \label{fig:exampleIntro}
  \end{figure}


\paragraph{Related work}
% TODO: Related Work

\paragraph{Structure} 
First we will introduce the basics of static analysis. This will go by introducing constraint systems and how these are used to gain information about the program statically. It will be accompanied by an example of a value-of-variables analysis acting on a toy language we will use for examples in this thesis. This will be extended to an interprocedural approach where partial context sensitivity will be introduced. Here the source of the precision loss will be pointed out. We then will propose an approach to combat this precision loss. The approach will first be introduced theoretically, after which we also present the challenges and results of implementing it in the \gob\ analyzer. To give an evaluation to the proposed approach, a benchmark of the implementation will be performed and inspected. Our conclusions are presented in the last chapter.
% TODO Thread
% TODO ref links to sections
