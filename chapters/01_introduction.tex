% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Introduction}\label{chapter:introduction}
  Abstract interpretation is a fascinating theory. When its principles are used in static analysis, one can proof certain properties about computer programs. Through the sound abstractions of abstract interpretation it is ensured that any proven property holds true for all possible executions of a program. The most interesting parts of this application are the different ways by which states of a program can be abstracted and how these abstractions can be combined to gain various kinds of information about a program.\\
  The \gob\ analyzer is a project that applies the principles of abstract interpretation to create a static analyzer \parencite{goblintHome}.\\
  This analyzer is specialized in, but not limited to finding concurrency bugs. These are some properties it aims to check:
  \begin{itemize}
    \item Race Detection: Checking that accesses to shared memory never happens simultaneously.
    \item Assertions and Dead Code: Checking whether specific logical expressions are definitely true at given points within the program. 
    \item Integer Overflows: Verifying that no integer overflows occur in the program.
  \end{itemize}
  To gain information about a program, \gob\ performs various kinds of analyses on the source code. These analyses abstract states of the program in different ways. They are also able to communicate with each other to profit from the information gained by other analyses. Because it is easily expandable, \gob\ is an interesting framework to try out new approaches in static analysis.\\
  \\
  The analyzer is highly configurable. This allows the user to fine-tune the degree of precision they wish. However, it has to be considered that usually a higher degree of precision also results in a higher computation time.\\
  With such a configuration option the user is able to specify the degree of context-sensitivity for each analysis. It is possible to set an analysis to be performed fully context-sensitively, context-insensitively or partially context-sensitively. Context sensitivity describes the degree to which entry states of functions are differentiated.\\
  \\
  Consider the program in \autoref{fig:exampleIntro}. Assume this program is analyzed with the goal to find which values the program variables can have during program execution. For that an analysis is used that tracks a set of integers for each variable, i.e., it computes an abstract state describing the possible values of all variables for each program point. The abstract state (in this case a set of values per variable) for a program point is computed by applying the effect of an action, e.g., an instruction, to the state before this action. Most actions have effects that are easily computable, however function calls are of a more complicated nature, as they can be called from multiple places in a program.\\
  The program in \autoref{fig:exampleIntro} contains two calls to \texttt{function()}, one in \autoref{code:call1} and the other in \autoref{code:call2}. If this program is analyzed context-sensitively, the function is analyzed twice: Once with an abstract entry state describing that "\texttt{glob} = 1" and once with a state describing "\texttt{glob} = 2". However, if the analysis is performed context-insensitively, both of these two entry states are joined into one abstract state which is used to analyze the function only once. This joined abstract state then has to describe the concrete states, where "\texttt{glob} = 1 or \texttt{glob} = 2", which is less precise than either of the individual states from before.\\
  When the state after a function call is computed, the information about \texttt{glob} is taken from the state returned from the callee. This is because \texttt{glob} is a global variable and thus its value can be changed in function calls.\\
  However, consider the case, where \texttt{glob} was not changed during the call to \texttt{function()}. Then the information about \texttt{glob} in the callee return state is the same as in the entry state for that specific call. This means, that in the case of the context-insensitive analysis, the less precise information "\texttt{glob} = 1 or \texttt{glob} = 2" from the joined entry state is used for \texttt{glob} after both calls. This is a loss of precision, considering that the value of \texttt{glob} was not altered in the call, and it would be sound to keep the information about \texttt{glob} from before each call.\\
  \\
  We think this precision loss is avoidable in many cases, where a piece of less precise information is taken from the callee state, even though that piece of information was not changed during the call. Thus, in this thesis we explore a way to reduce this kind of precision loss of partial contexts in abstract interpretation. 

  \begin{figure}
    \centering
    \begin{subfigure}{0.35\textwidth}
      \centering
      \lstinputlisting[escapechar=|, language=C]{../code/01-example_intro.c}
    \end{subfigure}
    \caption{C code sample with multiple function calls}
    \label{fig:exampleIntro}
  \end{figure}


\paragraph{Related work}
% TODO: Related Work

\paragraph{Structure} 
This thesis is structured as follows: First we discuss the basics of static analysis in \autoref{chapter:background}. For this we introduce constraint systems and how these are used to gain information about the program statically. This is accompanied by the example of a value-of-variables analysis acting on a toy language we use to exemplify static analyses in this thesis. We explain how we handle interprocedural analysis and introduce partial context-sensitivity. Here a source of the precision loss is identified. In the following two chapters we take a closer look at two kinds of analyses that suffer from this loss of precision in different ways and propose an approach to reduce the precision loss for each kind: In \autoref{chapter:precisionLossVariableAnalyses} we aim to improve analyses that track information about variables and in \autoref{chapter:precisionLossThreadAnalyses} we give an approach to reduce the precision loss of a thread related analysis. Both approaches are first discussed conceptually, after we present the challenges and results of implementing them in the \gob\ analyzer. To give an evaluation to the proposed approaches, a benchmark of the implementation will be performed and inspected in \autoref{chapter:evaluation}. Our conclusions are presented in \autoref{chapter:conclusions}.
