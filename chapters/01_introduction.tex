% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Introduction}\label{chapter:introduction}
  Abstract interpretation is a fascinating theory. When its principles are used in static analysis, one can proof certain properties about computer programs. Through the sound abstractions of abstract interpretation it is ensured that any proven property holds true for any possible execution of a program. The most interesting part of this system are the different ways by which states of a program can be abstracted and how these abstractions can be combined to gain various kinds of information about a program.\\
  One project that is concerned with applying the principles of abstract interpretation to create a static analyzer is the \gob analyzer\parencite{goblintHome}. This analyzer is specialized in but not limited to finding concurrency bugs. These are some properties it aims to check:
  \begin{itemize}
    \item Race Detection: Checking that accesses to shared memory never happens simultaneously.
    \item Assertions and Dead code: Checking whether specific logical expressions are definitely true at given points within the program. 
    \item Integer Overflows: Verifying that no integer overflows occur in the program.
  \end{itemize}
  To gain information about a program, \gob\ performs various kinds of analyses on the source code. These analyses abstract states of the program in different ways and are able to communicate with each other to profit from the information gained by other analyses. Because it is easily expandable, \gob\ is an interesting framework to try out new approaches in static analysis.\\
  \\
  The analyzer is highly configurable. This allows the user to fine-tune the degree of precision they wish. Usually a higher degree of precision also results in a higher computation time.\\
  One such configuration option allows the user to specify a set of analyses which are not performed context sensitively but rather context insensitively or only partially context sensitively. Context sensitivity describes the degree to which entry states of functions are differentiated.\\
  % abstract state
  For an example consider the program in <Fig TODO>. Assume we analyze this program with the goal to find which values the program variables can have during program execution. For that we use an analysis that tracks a set of integers for each variable, i.e., it computes an abstract state for each program point. An abstract state describes all concrete states, a program can have. The abstract state (in the case of this example a set of values per variable) for a program point is computed by applying effect of an action, e.g., an instruction, to the state before this action. Most actions have effects that are easily computable, however function calls are of a more complicated nature, as they can be called from multiple places in a program. In this example there are two possibilities to handle function calls:\\
  One option is the following: The analyzer enters the function with the current state, analyzes the function by going through its instructions and returns to the caller with the state it computes for the return statement. This state is then propagated up to the second call, where the function is analyzed again with the current state as the entry state. This is a context-sensitive analysis.\\
  Alternatively, the analyzer can be configured to only analyze the function once. For this it takes all possible states into account, with which the function could be entered. It creates a joint state that describes all possible entry states at the same time. This joint state is usually less precise than the individual entry states, because it has to represent all concrete states, that are represented by at least one of the entry states. The analyzer then analyzes the function with the joint entry state and returns the resulting state. In the caller it uses the same returned state after both calls to continue the analysis. This is a context-insensitive analysis.\\
  While the context-sensitive approach is more costly in terms of computation time (the function is analyzed twice instead of once), it is also more precise. This is because in the context-insensitive approach the analyzer created the joint context and analyzed the function with that. 
  %Effect: unchanged variable
  %\lstinputlisting[language=C]{../code/01-example_intro.c}

\paragraph{Related work}
% TODO: Related Work

\paragraph{Structure} 
First we will introduce the basics of static analysis. This will go by introducing constraint systems and how these are used to gain information about the program statically. It will be accompanied by an example of a value-of-variables analysis acting on a toy language we will use for examples in this thesis. This will be extended to an interprocedural approach where partial context sensitivity will be introduced. Here the source of the precision loss will be pointed out. We then will propose an approach to combat this precision loss. The approach will first be introduced theoretically, after which we also present the challenges and results of implementing it in the \gob\ analyzer. To give an evaluation to the proposed approach, a benchmark of the implementation will be performed and inspected. Our conclusions are presented in the last chapter.
% TODO Thread
% TODO ref links to sections
